\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[lined,boxed]{algorithm2e}

\sloppy

\title{Le problème du voyageur de commerce : Implémentation d'un algorithme de résolution}
\author{Guéneau Armaël \and Gledel Valentin}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}

\paragraph*{}
Le « Voyageur du commerce » est un problème algorithmique classique, pour lequel de nombreuses solutions approchées existent , bien que la résolution exacte soit difficile. Celui-ci peut se modéliser par un voyageur de commerce possédant une liste de villes à visiter pour vendre ses produits, et qui cherche à minimiser le temps qu’il passe sur la route. Connaissant la liste des villes et les distances entres elles, on veut alors trouver l’ordre dans lequel les parcourir pour que la distance totale parcourue soit minimale. Ce problème est NP-complet, il nous est donc impossible de trouver un algorithme trouvant une solution optimale et fonctionnant en un temps raisonnable.
\paragraph*{}
Dans le cadre du projet~1 en C, nous avons alors implémenté en binôme un algorithme de résolution approchée de ce problème, ainsi qu’une interface utilisateur permettant de sélectionner aisément les villes à parcourir par le voyageur dans une base de donnée.
L’algorithme choisi repose sur le parcours d'un arbre couvrant minimal pour le graphe des villes, construit à l'aide de l'algorithme de Kruskal. Il nous a fallu ensuite implémenter une base de données stockant des villes à parcourir par le voyageur et une interface utilisateur.
\paragraph*{}
Nous allons tout d’abord présenter les algorithmes que nous avons cherché à implémenter tout au long du projet : ceux-ci reposant sur des structures sous-jacentes, celà fera apparaître les contraintes sur celles-ci, ce qui sera attendu a priori. Alors, nous pourrons détailler leur implémentation, sous forme de bibliothèques indépendantes, prêtes à être utilisées ultérieurement. Ceci étant fait, et des bibliothèques propres à notre disposition, nous pourrons expliciter notre implémentation des algorithmes utilisant ces structures. Finalement, nous parlerons des problématiques liées au développement en langage de programmation C, les bibliothèques et les outils utilisés.

\bigskip

\section{Algorithmes}

\subsection{TSP}
Le cœur du projet repose sur l'utilisation d'un algorithme glouton, nommé ici \emph{TSP}. Celui-ci donne une solution approchée au problème du voyageur du commerce, appelée \textit{tournée} , sous la forme d'une liste de villes. La description de l'algorithme est la suivante :

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{Le graphe $G$ des villes et sa fonction de poids $w$}
  \KwResult{\textit{Tournée} pour le voyageur du commerce (liste de villes)}
  $T := $ un arbre couvrant minimal de $G$\;
  $L := $ parcours\_préfixe($T$)\;
  retourner $L$\;
  \caption{Algorithme TSP}
\end{algorithm}

\emph{TSP} repose ainsi sur des structures de graphe, d'arbre et de liste. \\
\begin{itemize}
\item Le graphe est donné par sa fonction de poids, et ici \emph{TSP} n'impose pas de contrainte supplémentaire sur les opérations que l'on veut pouvoir faire sur le graphe, puisqu'il le passe simplement en argument à la fonction de calcul d'arbre couvrant minimal.
\item La structure d'arbre doit pouvoir se parcourir efficacement. Une implémentation telle que réalisée en TP semble convenir pour le moment (un arbre est un nœud racine et des pointeurs vers les fils), adaptée pour gérer un nombre quelconque de fils.
\end{itemize}

\subsection{Algorithmes de Kruskal}

\paragraph*{} L'algorithme de Kruskal est l'algorithme qui permet de construire l'arbre couvrant minimal. Il s'agit de réunir toutes les arêtes du graphe en un seul arbre. On commence par trier toutes les arêtes par ordre croissant de poids. Puis on construit une forêt qui est initialement composée d'arbres dont le seul noeud est la racine avec chaque racine étiquettée par un sommet différent du graphe. Il s'agit ensuite de lier les arbres en parcourant les arêtes : si les deux sommets qui constituent l'arête en tête de liste appartiennent à des arbres différents, on lie ces deux arbres par ces sommets; sinon on passe à l'arête suivante.
\paragraph*{}
Formellement celà s'écrit :

\medskip

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Le graphe G=(V, E) des villes et sa fonction de poids $w$}
\KwResult{T, un arbre couvrant minimal du graphe}
Trier E par ordre croissant de poids selon $w$\;
Construire la forêt F, composée des arbres associés aux sommets\;
\ForEach{e=(v1, v2) $\in$ E $trié$}{
\eIf{v1 et v2 appartiennent à un arbre différent}{
Lier v1 et v2, et donc les arbres qui les contiennent\;
}{
Passer à l'arête suivante\;
}
}
\caption{Algorithme de Kruskal}
\end{algorithm}

\medskip

Pour des raisons de complexité, nous voulons pouvoir vérifier que deux sommets n'appartiennent pas au même arbre et lier deux arbres en temps constant. Cela entraîne deux contraintes :
\begin{itemize}
\item Les arbres doivent être non-enracinés pour pouvoir les lier aisément.
\item La forêt doit avoir une structure permettant une vérification instantanée de l'appartenance à un arbre.
\end{itemize}

\subsection{Parcours de tries}

\paragraph*{}Les tries dont nous détaillerons l'implémentation dans la Section~\ref{se:structures} nous ont semblé être adaptées pour gérer des nombreuses villes et leur coordonnées. En effet, leur structure sous forme de dictionnaire permet de retrouver rapidement une ville comme nous allons le constater.

\section{Les structures de données}
\label{se:structures}

Une fois les algorithmes choisis (TSP nous était imposé et Kruskal fortement imposé), il nous fallait choisir les structures de données adaptées. La plupart des structures ont été conçues sous forme de bibliothèques de sorte à pouvoir éventuellement resservir pour d'autres projets. Cependant, pour l'algorithme de \emph{Kruskal} nous avons développé des structures spécifiques.

\subsection{La structure Generic}

\begin{verbatim}
typedef union {
  void* p;
  int i;
  float f;
  double d;
} Generic;
\end{verbatim}

\subsection{Les vector}

\begin{verbatim}
typedef struct Vector {
  Generic* content; /* Generic array */
  int size;
} Vector;
\end{verbatim}

\subsection{Le graphe}

Le graphe n'est pas représenté par une structure usuelle de graphe avec une liste de sommets et d'arêtes. En effet, chaque sommet du graphe est lié à chaque autre il est donc inutile et lourd de garder en mémoire une structure de graphe avec des arêtes.

\subsection{Arbres non-enracinée}

\begin{verbatim}
typedef struct ftree {
  Generic data;
  Vector *neighbors;
  int neighborsNb;
} Ftree;
\end{verbatim}

\subsection{Structures utilisées dans l'algorithme de Kruskal}

\subsubsection{Listes d'arêtes}

\begin{verbatim}
typedef struct kedge {
  int n1;
  Ftree* addr1;

  int n2;
  Ftree* addr2;

  float weight;

  struct kedge *next;
} Kedge;
\end{verbatim}

\subsubsection{Forêts}

\begin{verbatim}
typedef struct forest {
  Vector* trees;
  int treesNb;
} Forest;
\end{verbatim}

\subsection{Les tries}

\begin{verbatim}
struct trie {
  float coord_x;
  float coord_y;
  int is_word;
  Letter* letters;
};

struct letter {
  char letter;
  Trie* next;
  struct letter *tail;
};
\end{verbatim}

\section{Implémentation des algorithmes}

\subsection{TSP}
L'algorithme \emph{TSP} ne fait en lui même pas grand chose : il s'agit d'appeler \emph{Kruskal}, puis de faire un parcours préfixe du \texttt{Ftree*} obtenu.

\paragraph*{}
Cela est fait de manière récursive par la fonction \texttt{prefixTravel_}. Le parcours d'un \texttt{Ftree*} est presque naturel, il faut simplement prendre garde de passer en argument, lors de l'appel récursif, l'adresse du nœud duquel on vient, celui-ci étant également voisin du nouveau nœud sur lequel on appelle.
\subsection{Algorithmes de Kruskal}

\subsection{Parcours de tries}

\section{Problématiques pratiques de développement : bibliothèques et outils utilisés}


\addcontentsline{toc}{section}{Conclusion}
\section*{Conclusion}


\end{document}
