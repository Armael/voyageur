\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[lined,boxed]{algorithm2e}

\sloppy

\title{Le problème du voyageur de commerce : Implémentation d'un algorithme de résolution}
\author{Guéneau Armaël \and Gledel Valentin}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}

\paragraph*{}
Le « Voyageur du commerce » est un problème algorithmique classique, pour lequel de nombreuses solutions approchées existent , bien que la résolution exacte soit difficile. Celui-ci peut se modéliser par un voyageur de commerce possédant une liste de villes à visiter pour vendre ses produits, et qui cherche à minimiser le temps qu’il passe sur la route. Connaissant la liste des villes et les distances entres elles, on veut alors trouver l’ordre dans lequel les parcourir pour que la distance totale parcourue soit minimale. Ce problème est NP-complet, il nous est donc impossible de trouver un algorithme trouvant une solution optimale et fonctionnant en un temps raisonnable.
\paragraph*{}
Dans le cadre du projet~1 en C, nous avons alors implémenté en binôme un algorithme de résolution approchée de ce problème, ainsi qu’une interface utilisateur permettant de sélectionner aisément les villes à parcourir par le voyageur dans une base de donnée.
L’algorithme choisi repose sur le parcours d'un arbre couvrant minimal pour le graphe des villes, construit à l'aide de l'algorithme de Kruskal. Il nous a fallu ensuite implémenter une base de données stockant des villes à parcourir par le voyageur et une interface utilisateur.
\paragraph*{}
Nous allons tout d’abord présenter les algorithmes que nous avons cherché à implémenter tout au long du projet : ceux-ci reposant sur des structures sous-jacentes, celà fera apparaître les contraintes sur celles-ci, ce qui sera attendu a priori. Alors, nous pourrons détailler leur implémentation, sous forme de bibliothèques indépendantes, prêtes à être utilisées ultérieurement. Ceci étant fait, et des bibliothèques propres à notre disposition, nous pourrons expliciter notre implémentation des algorithmes utilisant ces structures. Finalement, nous parlerons des problématiques liées au développement en langage de programmation C, les bibliothèques et les outils utilisés.

\bigskip

\section{Algorithmes}

\subsection{TSP}
Le cœur du projet repose sur l'utilisation d'un algorithme glouton, nommé ici \emph{TSP}. Celui-ci donne une solution approchée au problème du voyageur du commerce, appelée \textit{tournée} , sous la forme d'une liste de villes. La description de l'algorithme est la suivante :

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{Le graphe $G$ des villes et sa fonction de poids $w$}
  \KwResult{\textit{Tournée} pour le voyageur du commerce (liste de villes)}
  $T := $ un arbre couvrant minimal de $G$\;
  $L := $ parcours\_préfixe($T$)\;
  retourner $L$\;
  \caption{Algorithme TSP}
\end{algorithm}

\emph{TSP} repose ainsi sur des structures de graphe, d'arbre et de liste. \\
\begin{itemize}
\item Le graphe est donné par sa fonction de poids, et ici \emph{TSP} n'impose pas de contrainte supplémentaire sur les opérations que l'on veut pouvoir faire sur le graphe, puisqu'il le passe simplement en argument à la fonction de calcul d'arbre couvrant minimal.
\item La structure d'arbre doit pouvoir se parcourir efficacement. Une implémentation telle que réalisée en TP semble convenir pour le moment (un arbre est un nœud racine et des pointeurs vers les fils), adaptée pour gérer un nombre quelconque de fils.
\end{itemize}

\subsection{Algorithmes de Kruskal}

\paragraph*{} L'algorithme de \emph{Kruskal} permet de construire un arbre couvrant minimal pour un graphe donné, à savoir un arbre composé de tous les sommets du graphe, et de poids minimal. Il commence par trier toutes les arêtes par ordre croissant de poids, puis construit une forêt qui est initialement composée d'arbres à un nœud, correspondant aux sommets du graphe. \\
Il s'agit ensuite de lier les arbres en parcourant les arêtes (triées) : si les deux sommets que lie l'arête appartiennent à des arbres différents dans la forêt, on relie ces deux arbres par ces sommets; sinon on passe à l'arête suivante.
\paragraph*{}
Formellement cela s'écrit :

\medskip

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Le graphe $G=(V, E)$ des villes et sa fonction de poids $w$}
\KwResult{$T$, un arbre couvrant minimal du graphe}
Trier $E$ par ordre croissant de poids selon $w$\;
Construire la forêt $F$, composée des arbres associés aux sommets\;
\ForEach{$e=(v1, v2)$ $\in$ $E$ $trié$}{
  \eIf{$v1$ et $v2$ appartiennent à un arbre différent}{
    Lier $v1$ et $v2$, et donc les arbres qui les contiennent\;
  }{
    Passer à l'arête suivante\;
  }
}
\caption{Algorithme de \emph{Kruskal}}
\end{algorithm}

\medskip

Pour améliorer les performances, nous voulons pouvoir vérifier que deux sommets n'appartiennent pas au même arbre et lier deux arbres en temps constant. Cela entraîne deux contraintes :
\begin{itemize}
\item Les arbres doivent être non-enracinés pour pouvoir les fusionner aisément.
\item La forêt doit avoir une structure permettant la vérification instantanée de l'appartenance à un arbre.
\end{itemize}

\subsection{Parcours de tries}

\paragraph*{}Les tries dont nous détaillerons l'implémentation dans la Section~\ref{se:structures} nous ont semblé être adaptées pour gérer des nombreuses villes et leur coordonnées. En effet, leur structure sous forme de dictionnaire permet de retrouver rapidement une ville comme nous allons le constater.

\section{Les structures de données}
\label{se:structures}

Une fois les algorithmes choisis et qu'a été définie la manière précise dont ils ont besoin d'utiliser les structures sous-jacentes, il faut effectivement les choisir et les implémenter. La plupart des structures ont été conçues sous forme de bibliothèques de sorte à pouvoir éventuellement resservir pour d'autres projets. Cependant, pour l'algorithme de \emph{Kruskal} nous avons développé des structures spécifiques.

\subsection{La structure Generic}

\begin{verbatim}
typedef union {
  void* p;
  int i;
  float f;
  double d;
} Generic;
\end{verbatim}

\subsection{Les vector}

\begin{verbatim}
typedef struct Vector {
  Generic* content; /* Generic array */
  int size;
} Vector;
\end{verbatim}

\subsection{Le graphe}

Le graphe n'est pas représenté par une structure usuelle de graphe avec une liste de sommets et d'arêtes. En effet, chaque sommet du graphe est lié à chaque autre il est donc inutile et lourd de garder en mémoire une structure de graphe avec des arêtes.

\subsection{Arbres non-enracinée}

Les arbres non-enracinés permettent de lier d'unir deux arbres par deux de leur noeuds sans avoir à se préoccuper de notion de racine à déplacer, chaque noeud de l'arbre représente l'arbre. Ceci nous permet de respecter les contraintes en complexité. 

\begin{verbatim}
typedef struct ftree {
  Generic data;
  Vector *neighbors;
  int neighborsNb;
} Ftree;
\end{verbatim}

\subsection{Structures utilisées dans l'algorithme de Kruskal}

Les structures liées à l'algorithmes de Kruskal sont particulières car nous ne les avons pas développé de manière à pouvoir reservir, la liste d'arêtes n'est en rien générale car elle contient des arbres non-enracinés ce qui est très spécifique, et les fonctions sur la structure des forêt sont spécifiquent à l'algorithme de Kruskal.

\subsubsection{Listes d'arêtes}

\begin{verbatim}
typedef struct kedge {
  int n1;
  Ftree* addr1;

  int n2;
  Ftree* addr2;

  float weight;

  struct kedge *next;
} Kedge;
\end{verbatim}

\subsubsection{Forêts}

\begin{verbatim}
typedef struct forest {
  Vector* trees;
  int treesNb;
} Forest;
\end{verbatim}

\subsection{Les tries}

\begin{verbatim}
struct trie {
  float coord_x;
  float coord_y;
  int is_word;
  Letter* letters;
};

struct letter {
  char letter;
  Trie* next;
  struct letter *tail;
};
\end{verbatim}

\section{Implémentation des algorithmes}

\subsection{TSP}
L'algorithme \emph{TSP} ne fait en lui même pas grand chose : il s'agit d'appeler \emph{Kruskal}, puis de faire un parcours préfixe du \texttt{Ftree*} obtenu.

\paragraph*{}
Cela est fait de manière récursive par la fonction \texttt{prefixTravel\_}. Le parcours d'un \texttt{Ftree*} est presque naturel, il faut simplement prendre garde de passer en argument, lors de l'appel récursif, l'adresse du nœud duquel on vient, celui-ci étant également voisin du nouveau nœud sur lequel on appelle.
\subsection{Algorithmes de Kruskal}

\subsection{Parcours de tries}

\section{Problématiques pratiques de développement : bibliothèques et outils utilisés}


\addcontentsline{toc}{section}{Conclusion}
\section*{Conclusion}


\end{document}
