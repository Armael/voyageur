\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{amsmath, amsthm, amssymb}
\usepackage[lined,boxed]{algorithm2e}

\sloppy

\title{Le problème du voyageur de commerce : Implémentation d'un algorithme de résolution}
\author{Guéneau Armaël \and Gledel Valentin}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}

\paragraph*{}
Le « Voyageur du commerce » est un problème algorithmique classique, pour lequel de nombreuses solutions approchées existent , bien que la résolution exacte soit difficile. Celui-ci peut se modéliser par un voyageur de commerce possédant une liste de villes à visiter pour vendre ses produits, et qui cherche à minimiser le temps qu’il passe sur la route. Connaissant la liste des villes et les distances entres elles, on veut alors trouver l’ordre dans lequel les parcourir pour que la distance totale parcourue soit minimale. Ce problème est NP-complet, il nous est donc impossible de trouver un algorithme trouvant une solution optimale et fonctionnant en un temps raisonnable.
\paragraph*{}
Dans le cadre du projet~1 en C, nous avons alors implémenté en binôme un algorithme de résolution approchée de ce problème, ainsi qu’une interface utilisateur permettant de sélectionner aisément les villes à parcourir par le voyageur dans une base de donnée.
L’algorithme choisi repose sur le parcours d'un arbre couvrant minimal pour le graphe des villes, construit à l'aide de l'algorithme de Kruskal. Il nous a fallu ensuite implémenter une base de données stockant des villes à parcourir par le voyageur et une interface utilisateur.
\paragraph*{}
Nous allons tout d’abord présenter les algorithmes que nous avons cherché à implémenter tout au long du projet : ceux-ci reposant sur des structures sous-jacentes, celà fera apparaître les contraintes sur celles-ci, ce qui sera attendu a priori. Alors, nous pourrons détailler leur implémentation, sous forme de bibliothèques indépendantes, prêtes à être utilisées ultérieurement. Ceci étant fait, et des bibliothèques propres à notre disposition, nous pourrons expliciter notre implémentation des algorithmes utilisant ces structures. Finalement, nous parlerons des problématiques liées au développement en langage de programmation C, les bibliothèques et les outils utilisés.

\bigskip

\section{Algorithmes}

\subsection{TSP}
Le cœur du projet repose sur l'utilisation d'un algorithme glouton, nommé ici \emph{TSP}. Celui-ci donne une solution approchée au problème du voyageur du commerce, appelée \textit{tournée} , sous la forme d'une liste de villes. La description de l'algorithme est la suivante :

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{Le graphe $G$ des villes et sa fonction de poids $w$}
  \KwResult{\textit{Tournée} pour le voyageur du commerce (liste de villes)}
  $T := $ un arbre couvrant minimal de $G$\;
  $L := $ parcours\_préfixe($T$)\;
  retourner $L$\;
  \caption{Algorithme TSP}
\end{algorithm}

\emph{TSP} repose ainsi sur des structures de graphe, d'arbre et de liste. \\
\begin{itemize}
\item Le graphe est donné par sa fonction de poids, et ici \emph{TSP} n'impose pas de contrainte supplémentaire sur les opérations que l'on veut pouvoir faire sur le graphe, puisqu'il le passe simplement en argument à la fonction de calcul d'arbre couvrant minimal.
\item La structure d'arbre doit pouvoir se parcourir efficacement. Une implémentation telle que réalisée en TP semble convenir pour le moment (un arbre est un nœud racine et des pointeurs vers les fils), adaptée pour gérer un nombre quelconque de fils.
\end{itemize}

\subsection{Algorithmes de Kruskal}

\paragraph*{} L'algorithme de \emph{Kruskal} permet de construire un arbre couvrant minimal pour un graphe donné, à savoir un arbre composé de tous les sommets du graphe, et de poids minimal. Il commence par trier toutes les arêtes par ordre croissant de poids, puis construit une forêt qui est initialement composée d'arbres à un nœud, correspondant aux sommets du graphe. \\
Il s'agit ensuite de lier les arbres en parcourant les arêtes (triées) : si les deux sommets que lie l'arête appartiennent à des arbres différents dans la forêt, on relie ces deux arbres par ces sommets; sinon on passe à l'arête suivante.
\paragraph*{}
Formellement cela s'écrit :

\medskip

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Le graphe $G=(V, E)$ des villes et sa fonction de poids $w$}
\KwResult{$T$, un arbre couvrant minimal du graphe}
Trier $E$ par ordre croissant de poids selon $w$\;
Construire la forêt $F$, composée des arbres associés aux sommets\;
\ForEach{$e=(v1, v2)$ $\in$ $E$ $trié$}{
  \eIf{$v1$ et $v2$ appartiennent à un arbre différent}{
    Lier $v1$ et $v2$, et donc les arbres qui les contiennent\;
  }{
    Passer à l'arête suivante\;
  }
}
\caption{Algorithme de \emph{Kruskal}}
\end{algorithm}

\medskip

Pour améliorer les performances, nous voulons pouvoir vérifier que deux sommets n'appartiennent pas au même arbre et lier deux arbres en temps constant. Cela entraîne deux contraintes :
\begin{itemize}
\item Les arbres doivent être non-enracinés pour pouvoir les fusionner aisément.
\item La forêt doit avoir une structure permettant la vérification instantanée de l'appartenance à un arbre.
\end{itemize}

\subsection{Parcours de tries}

\paragraph*{}Les tries dont nous détaillerons l'implémentation dans la Section~\ref{se:structures} nous ont semblé être adaptées pour gérer des nombreuses villes et leur coordonnées. En effet, leur structure sous forme de dictionnaire permet de retrouver rapidement une ville comme nous allons le constater.

\medskip

\begin{algorithm}[H]
\SetAlgoLined
\KwData{La chaine de carractère $(c_{i})_{i \in [0,n-1]}$ correspondant au nom de la ville recherchée et la trie contenant les données}
\KwResult{Les coordonnées de cette ville ou une erreur si elle n'est pas présente}
\eIf{La lettre $c_{0}$ est présente à cette étage de la trie}{
	\eIf{La chaine de caractère ne contient qu'un seul caractère}{
		\eIf{La trie est terminale à cet endroit}{
			Renvoyer les coordonnées\;
		}{
			Renvoyer une erreur\;
		}
	}{
		Appliquer cet algorithme à la trie fille et à la chaine $(c_{i})_{i \in [1,n-1]}$\;
	}
}{
			Renvoyer une erreur\;
}
}
\caption{Algorithme de parcours de trie}
\end{algorithm}

\medskip

La recherche du caractère à un étage donné de la trie ce fait en temps constant donc la compléxité est en $\Theta$(longueur de la chaine de caractères).

\section{Les structures de données}
\label{se:structures}

Une fois les algorithmes choisis et qu'a été définie la manière précise dont ils ont besoin d'utiliser les structures sous-jacentes, il faut effectivement les choisir et les implémenter. La plupart des structures ont été conçues sous forme de bibliothèques de sorte à pouvoir éventuellement resservir pour d'autres projets. Cependant, pour l'algorithme de \emph{Kruskal} nous avons développé des structures spécifiques.

\subsection{La structure Generic}

\begin{verbatim}
typedef union {
  void* p;
  int i;
  float f;
  double d;
} Generic;
\end{verbatim}

\subsection{Les vector}


\begin{verbatim}
typedef struct Vector {
  Generic* content; /* Generic array */
  int size;
} Vector;
\end{verbatim}

\subsection{Le graphe}

Le graphe n'est pas représenté par une structure usuelle de graphe avec une liste de sommets et d'arêtes. En effet, chaque sommet du graphe est lié à chaque autre il est donc inutile et lourd de garder en mémoire une structure de graphe avec des arêtes.

\subsection{Arbres non-enracinée}

Les arbres non-enracinés (free trees en anglais, d'où le nom Ftree) permettent de lier d'unir deux arbres par deux de leur noeuds sans avoir à se préoccuper de notion de racine à déplacer, chaque noeud de l'arbre représente l'arbre. Ceci nous permet de respecter les contraintes en compléxité. 

\begin{verbatim}
typedef struct ftree {
  Generic data;
  Vector *neighbors;
  int neighborsNb;
} Ftree;
\end{verbatim}

La structure ne comprend pas le concept de fils mais de voisins ce qui évite d'avoir à choisir une différence de hauteur dans l'arbre.

\subsection{Structures utilisées dans l'algorithme de Kruskal}

Les structures liées à l'algorithmes de Kruskal sont particulières car nous ne les avons pas développé de manière à pouvoir reservir, la liste d'arêtes n'est en rien générale car elle contient des arbres non-enracinés ce qui est très spécifique, et les fonctions sur la structure des forêt sont spécifiquent à l'algorithme de Kruskal.

\subsubsection{Listes d'arêtes}

L'algorithme de Kruskal nécessite de trier les arêtes, il nous fallait donc une structure pour contenir ces arêtes. Nous avons choisi d'utiliser une liste afin de pouvoir par la suite nous servi de l'agorithme tri-fusion.

\begin{verbatim}
typedef struct kedge {
  int n1;
  Ftree* addr1;

  int n2;
  Ftree* addr2;

  float weight;

  struct kedge *next;
} Kedge;
\end{verbatim}

Chaque arête contient son poids, les numéros des sommets qu'elle lie et des pointeur vers les arbres qui leur sont associés. Cela permet de lier les arbres en temps constant car on accède directement au bon noeud.

\subsubsection{Forêts}

\begin{verbatim}
typedef struct forest {
  Vector* trees;
  int treesNb;
} Forest;
\end{verbatim}

La forêt est ici codée un vector, ce qui permet d'accéder instantanément à l'arbre associée à un sommet du graphe à l'aide des indices dans les arêtes. Alors que l'algorithme de Kruskal avance, le nombre d'arbres identiques augmente et les éléments d'indices appartenant au même arbre vont être exactement le même noeud. Ce qui permet de comparer rapidement si deux sommets appartiennent au même arbre. Toutefois, la compléxité pour répendre ce noeud dans le vecteur est linéaire ce qui augmente la compléxité totale de l'algorithme de Kruskal.

\subsection{Les tries}

\begin{verbatim}
struct trie {
  float coord_x;
  float coord_y;
  int is_word;
  Letter* letters;
};

struct letter {
  char letter;
  Trie* next;
  struct letter *tail;
};
\end{verbatim}

\section{Implémentation des algorithmes}

\subsection{TSP}
L'algorithme \emph{TSP} ne fait en lui même pas grand chose : il s'agit d'appeler \emph{Kruskal}, puis de faire un parcours préfixe du \texttt{Ftree*} obtenu.

\paragraph*{}
Cela est fait de manière récursive par la fonction \texttt{prefixTravel\_}. Le parcours d'un \texttt{Ftree*} est presque naturel, il faut simplement prendre garde de passer en argument, lors de l'appel récursif, l'adresse du nœud duquel on vient, celui-ci étant également voisin du nouveau nœud sur lequel on appelle.
\subsection{Algorithmes de Kruskal}

\subsection{Parcours de tries}

\section{Problématiques pratiques de développement : bibliothèques et outils utilisés}


\addcontentsline{toc}{section}{Conclusion}
\section*{Conclusion}
\paragraph*{}
Nous obtenons donc à l'aide de l'algorithme de Kruskal et de l'algorithme TSP, une résolution du problème du voyageur de commerce qui, même si elle n'est pas optimale, renvoie des résultats acceptable. En effet, les tests que nous avons effectuer nous ont permis de constater que les résultats obtenus ne contenaient pas de parcours absurdes dont il est évident qu'ils sont bien trop long.
\paragraph*{}
La structure de donnée crée à l'aide des tries permet de charger des milliers de villes (l'ensemble des villes française) en quelque seconde et de ressortir celle demandée en un temps aussi acceptable.
\paragraph*{}
L'interface utilisateur utilisant les convention UNIX permet de chargés differentes bases de données (uniquement les grandes villes française ou aussi les petites communes), de rentrer une liste de ville à parcourir à la main ou à l'aide d'un fichier texte.
\paragraph*{}
Nous avons rencontrer des difficultées de compléxité qui empêchaient d'appliquer le programme à un trop grand nombre de ville (de l'ordre du millier) et qui nous ont amené à changer certaine de nos structure de données notament la structure de graphe pour obtenir des fonctions bien plus rapide.
\paragraph*{}
Toutefois, le programme n'est pas encore optimal. Même si appliquer l'algorithme à 3000 villes ne prend plus que 12 seconde, il reste difficile d'atteindre 10 000 villes. La structure de donnée stockant les arêtes peut être la source de cette faiblesse. Une amélioration possible serait de remplacer la structure de liste par un tableau qui permettrait de trier sur place les arêtes.





\end{document}
